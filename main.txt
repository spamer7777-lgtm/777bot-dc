using Discord;
using Discord.Interactions;
using Discord.WebSocket;
using System;
using System.Reflection;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using Performance;

public static class Bot
{
    private const ulong TubasStickerId = 1435403416733225174;
    private const ulong RozkminkaStickerId = 1435646701137428511;

    public static readonly DiscordSocketClient Client = new(new DiscordSocketConfig
    {
        GatewayIntents = GatewayIntents.AllUnprivileged | GatewayIntents.MessageContent
    });

    private static InteractionService Service;
    private static readonly string Token = "MTQzNTM0NTIyNTU1MDkyMTczOQ.GPq8Jr.CwNZV7YZ5b7KYHynYz3NKOcksKgzrzMs0R6Eto";
    private static Timer timer;

    // ðŸŸ¢ Nowy globalny HttpClient z poprawnymi nagÅ‚Ã³wkami
    public static readonly HttpClient Http = new HttpClient(new HttpClientHandler
    {
        AllowAutoRedirect = true,
        UseProxy = true
    })
    {
        Timeout = TimeSpan.FromSeconds(10)
    };

    // ðŸŸ¢ Statyczny konstruktor â€” dodaje nagÅ‚Ã³wki
    static Bot()
    {
        Http.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64) DiscordBot/1.0");
        Http.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
    }

    public static async Task Main()
    {
        if (Token is null)
            throw new ArgumentException("Discord bot token not set properly.");

        Client.Ready += Ready;
        Client.Log += Log;
        Client.MessageReceived += MessageReceivedHandler;

        await Client.LoginAsync(TokenType.Bot, Token);
        await Client.StartAsync();
        await Task.Delay(Timeout.Infinite);
    }

    private static async Task MessageReceivedHandler(SocketMessage message)
    {
        if (message.Author.Id == Client.CurrentUser.Id) return;
        if (message.Author is not SocketGuildUser user) return;
        if (message.Attachments.Any()) return;

        string contentLower = message.Content.ToLowerInvariant();
        string[] words = contentLower.Split(' ', StringSplitOptions.RemoveEmptyEntries);

        bool containsXddd = words.Contains("xddddd");
        bool containsTubas = words.Contains("tubas");
        bool containsRozkminka = words.Contains("co?");

        int triggerCount = new[] { containsXddd, containsTubas, containsRozkminka }.Count(b => b);
        if (triggerCount != 1) return;

        if (containsXddd)
            await HandleXdddDetection(message, user);
        else if (containsTubas)
            await HandleTubasDetection(message, user);
        else if (containsRozkminka)
            await HandleRozkminkaDetection(message, user);
    }

    private static async Task HandleXdddDetection(SocketMessage message, SocketGuildUser user)
    {
        Console.WriteLine($"[XDDD DETECTED] from {user.Username} in #{message.Channel.Name}");
        var kekwEmoji = Client.Guilds.SelectMany(g => g.Emotes)
            .FirstOrDefault(e => e.Name.Equals("kekw", StringComparison.OrdinalIgnoreCase));

        if (kekwEmoji != null && message.Channel is SocketTextChannel textChannel)
        {
            var botUser = textChannel.Guild.CurrentUser;
            if (!botUser.GetPermissions(textChannel).SendMessages) return;

            await message.Channel.SendMessageAsync(kekwEmoji.ToString());
            Console.WriteLine($"[XDDD SUCCESS] Sent {kekwEmoji}");
        }
    }

    private static async Task HandleTubasDetection(SocketMessage message, SocketGuildUser user)
    {
        Console.WriteLine($"[TUBAS DETECTED] from {user.Username} in #{message.Channel.Name}");
        if (message.Channel is not SocketTextChannel textChannel) return;
        var botUser = textChannel.Guild.CurrentUser;
        if (!botUser.GetPermissions(textChannel).SendMessages) return;

        try
        {
            var sticker = textChannel.Guild.Stickers.FirstOrDefault(s => s.Id == TubasStickerId);
            if (sticker != null)
                await textChannel.SendMessageAsync(stickers: new[] { sticker });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[TUBAS ERROR] {ex.Message}");
        }
    }

    private static async Task HandleRozkminkaDetection(SocketMessage message, SocketGuildUser user)
    {
        Console.WriteLine($"[ROZKMINKA DETECTED] from {user.Username} in #{message.Channel.Name}");
        if (message.Channel is not SocketTextChannel textChannel) return;
        var botUser = textChannel.Guild.CurrentUser;
        if (!botUser.GetPermissions(textChannel).SendMessages) return;

        try
        {
            var sticker = textChannel.Guild.Stickers.FirstOrDefault(s => s.Id == RozkminkaStickerId);
            if (sticker != null)
                await textChannel.SendMessageAsync(stickers: new[] { sticker });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ROZKMINKA ERROR] {ex.Message}");
        }
    }

    private static async Task Ready()
    {
        Service = new(Client, new InteractionServiceConfig
        {
            UseCompiledLambda = true,
            ThrowOnError = true
        });

        await Service.AddModulesAsync(Assembly.GetEntryAssembly(), null);
        await Service.RegisterCommandsGloballyAsync();
        Client.InteractionCreated += InteractionCreated;
        Service.SlashCommandExecuted += SlashCommandResulted;

        Console.WriteLine($"Bot is ready! Connected to {Client.Guilds.Count} guild(s).");
        await Client.SetGameAsync("777 Slots", type: ActivityType.Playing);

        string[] statuses = { "No Siemano!", "Ale kto pytaÅ‚?", "Ale sigiemki tutaj" };
        int index = 0;
        bool showGame = false;

        timer = new Timer(async _ =>
        {
            if (Client.ConnectionState != ConnectionState.Connected) return;
            try
            {
                if (showGame)
                    await Client.SetGameAsync("777 Slots", type: ActivityType.Playing);
                else
                    await Client.SetCustomStatusAsync(statuses[index]);

                index = (index + 1) % statuses.Length;
                showGame = !showGame;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[STATUS ERROR] {ex.Message}");
            }
        }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(20));
    }

    private static async Task InteractionCreated(SocketInteraction interaction)
    {
        try
        {
            var ctx = new SocketInteractionContext(Client, interaction);
            await Service.ExecuteCommandAsync(ctx, null);
        }
        catch
        {
            if (interaction.Type == InteractionType.ApplicationCommand)
                await interaction.GetOriginalResponseAsync()
                    .ContinueWith(async msg => await msg.Result.DeleteAsync());
        }
    }

    private static async Task SlashCommandResulted(SlashCommandInfo info, IInteractionContext ctx, IResult res)
    {
        if (!res.IsSuccess)
            await ctx.Interaction.FollowupAsync($"âŒ Error: {res.ErrorReason}", ephemeral: true);
        else
        {
            var cpuUsage = await Stats.GetCpuUsageForProcess();
            var ramUsage = Stats.GetRamUsageForProcess();
            Console.WriteLine($"{DateTime.Now:dd/MM. H:mm:ss} | CPU: {cpuUsage}% | RAM: {ramUsage}% | Command: {info.Name}");
        }
    }

    private static Task Log(LogMessage logMessage)
    {
        Console.ForegroundColor = logMessage.Severity switch
        {
            LogSeverity.Critical => ConsoleColor.Red,
            LogSeverity.Debug => ConsoleColor.Blue,
            LogSeverity.Error => ConsoleColor.Yellow,
            LogSeverity.Info => ConsoleColor.Cyan,
            LogSeverity.Verbose => ConsoleColor.Green,
            LogSeverity.Warning => ConsoleColor.Magenta,
            _ => ConsoleColor.White,
        };
        Console.WriteLine($"{DateTime.Now:dd/MM. H:mm:ss} [{logMessage.Source}] {logMessage.Message}");
        Console.ResetColor();
        return Task.CompletedTask;
    }
}

